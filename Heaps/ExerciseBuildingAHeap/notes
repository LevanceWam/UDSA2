This is the notes for ExerciseBuildingAHeap

Lets try to implement a heap. We normally use an array to implement a heap
even though a heap is conceptually binary tree. But because 
heaps are complete binary treea and we don't have holes in them 
it is more efficient to store them in a array 

To implement them using a array we can simply store these values
in a array so we dont need a node class with fields for left and right children
so our heap is going to have a smaller footprint in memory

so if we have a heap with 5 items (look to the screenshot)
we can store the items at these indexes
So from the top root we start at 0 then from left to right go 
1 2 3 4 

now for the bubbling up and bubbling down operations 
we need to be able to find the children or the parent of a node 
lets see how to do this 

so if we look at the index of 10 and compare it to the index of its children
what is the relationship?

if we multiply 1 by 2 and then add the 1 to it we get the index of the left children
or if we multiply 1 by 2 and then add 2 to it we get the index of the right track

Here are the formulas for calculating the index of the right and left children
Left = parent * 2 + 1
right = parent * 2 + 2

How can we find the parent of the node?
let's look at the indexes again
how do we get to 1 from 3 well we subtract 3-1 and then divide by 2
here is the formula to calculate the index of a parent node :
parent = (index-1) / 2


so this is what we need to do we need to create a heap class and we need to use a array to store 
a list of intergers and implement to operations 

Insert:
gets a interger 

Remove:
removes the root node 

remember when we implement these operations we need to bubble up or down a value 

solution:

Part 1 insert method:
first we need to create the heap class and set some private varibles 
we need to set one for the array we plan on using

we need to had a size field to keep track of the number of items in the heap
because later when we implement the remove operation we're simply going to 
decrease the value of the size 

we're not going to physically remove our items from the array

so next we are going to want to create the insert method with the parameter of value 
we are going to want to store the value to the next available spot 
so we are going to set array of size to the value:
array[size++] = value 
here the size count is going to indecate where we are going to store the value at
so if the first number we store is 1 it will have a index of 0 because the size is zero

(It is important to note that this style of programming is something we picked up 
while looking at java code because in java arrays have limits 
JS doesn't because it is dynamic if )

This is how we are going to store the item in the next available slot now we are going to work
on the bubble up operation if the item is greater than the parent
that means we should bubble up this item until it is in the right 
position

next we need to calculate the index which is size minus 1 

while we are here we also need to calculate the parent index
which is index - 1 / 2 
we also need to wrap this equation inside of a math.floor  function 
this is because some of the indexes will return a float and indexes are not stored at floats

(and remember The Math. floor method is used to round off the number passed
 as a parameter to its nearest integer in 
Downward direction of rounding i.e. towards the lesser value.)

now we are going to need a while statement 
now as long as the item at the current index is greater than the item at the parent index 
we are going to have to swap those items 

now we need to implement a swap method we are going to make this a seperate private method 
outside of the insert method because we do not want to make it super bulky

so we intialize swap with the parameters of first and second to represent the indexes
then we create the swap method 
we create a variable called temp this will hold the value of the first index
next we are going to copy the second item into the first item
finally what ever is in the temp we are going to copy it into the second item 

Back in the while statement in the insert method
now if the item in the current index is greater than the parent index we need to swap them
so we execute swap with the index and the parent index as parameters

now we need to set the index to the parent index
this way if the item is still greater than the new parent we can swap it in the next iteration

now we finish this is our bubbleup method lets move it inside of its own private method to make the code
cleaner
next we are going to call the bubbleup method in the insert method

Part 2 
Remove method:
We are going to move on to the remove operation
This one is a little more tricky because there are a few edge cases and we need to acoount for it 

so we are going to declare the remove method with no parameters 
this is because we are always going to be removing the root node which holds the largest 
value. 

The first thing we need to do is move the last node into the root node
once we do that we are going to decrement the size by one.

We can code it all into one line to make it easier on us

now once we remove the item we need to execute the bubble down operation
after we removed the item 

if the item is smaller than its childern then we need to keep doing this until we are in the right position
we are going to need a while loop
we are going to want to create a index variable and set it to 0 this is going to change every iteration
while this item[index] < children we are going to swap the values 

we are going to need to create 2 private methods to calculate the left and right child  

